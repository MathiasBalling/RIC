
use std::collections::VecDeque;

use opencv::{
    core::{self, Mat, Point2i, Scalar, Vec3b},
    highgui,
    prelude::*,
};

use crate::util::{self, is_obstacle, is_valid_position};

const WINDOW_NAME: &str = "Generalized Voronoi Diagram (GVD)";

const UNINITIALIZED_LABEL: u8 = 254;
const EDGE_LABEL: u8 = 255;

const DIRECTIONS: [(i32, i32); 4] = [(0, 1), (1, 0), (0, -1), (-1, 0)];

fn add_label(
    img: &Mat,
    obstacle_label_map: &mut Mat,
    pos: Point2i,
    obstacle_label_idx: &mut u8,
    obstacle_queue: &mut VecDeque<Point2i>,
) {
    // Find the label of the neighbor
    // If all the neighbors have the same label or are unexplored, assign a new label
    // If the neighbors have different labels and is obstacle, we need to merge the labels
    let mut neighbor_labels = Vec::new();
    for (dx, dy) in DIRECTIONS {
        let neighbor_pos = Point2i::new(pos.x + dx, pos.y + dy);
        if is_valid_position(img, neighbor_pos) {
            let neighbor_label = obstacle_label_map
                .at_2d::<u8>(neighbor_pos.y, neighbor_pos.x)
                .unwrap();
            if *neighbor_label != UNINITIALIZED_LABEL {
                neighbor_labels.push(*neighbor_label);
            }
        }
    }

    let obstacle_label = obstacle_label_map.at_2d_mut::<u8>(pos.y, pos.x).unwrap();
    if neighbor_labels.is_empty() && is_obstacle(img, pos) {
        // Assign a new label
        *obstacle_label = *obstacle_label_idx;
        *obstacle_label_idx += 1;
        return;
    }

    // Find the min and max labels for the neighbors
    let max_label = *neighbor_labels.iter().max().unwrap();
    let min_label = *neighbor_labels.iter().min().unwrap();

    // Assign the min label to the current pixel
    *obstacle_label = min_label;

    // If all the neighbors have the same label, return
    if max_label == min_label {
        return;
    }

    // Merge the labels
    *obstacle_label = min_label;
    // Merge the labels or mark edges with 0 (Voronoi edges)
    for (dx, dy) in DIRECTIONS {
        let neighbor_pos = Point2i::new(pos.x + dx, pos.y + dy);
        if is_valid_position(img, neighbor_pos) {
            let neighbor_label = obstacle_label_map
                .at_2d::<u8>(neighbor_pos.y, neighbor_pos.x)
                .unwrap();
            if *neighbor_label != min_label {
                obstacle_queue.push_back(neighbor_pos);
            }
        }
    }
}

pub fn gvd(img: &Mat, dtm_img: &Mat, mut obstacle_queue: VecDeque<core::Point2i>) {
    println!("Performing Generalized Voronoi Diagram (GVD) algorithm");

    let mut obstacle_label_map = Mat::new_rows_cols_with_default(
        img.rows(),
        img.cols(),
        core::CV_8UC1,
        Scalar::all(UNINITIALIZED_LABEL as f64),
    )
    .expect("failed to create obstacle label map");

    let mut obstacle_queue_copy = obstacle_queue.clone();

    // Map obstacle pixels
    // 254 is Voronoi edges. 0 to 3 are the walls. 4 and up are obstacles. 255 is unexplored.
    // Start indexing at 5
    let mut obstacle_label_idx = 4;

    // Breadth-First Search (BFS) to propagate obstacle labels
    while let Some(pos) = obstacle_queue.pop_front() {
        let obstacle_label = obstacle_label_map.at_2d_mut::<u8>(pos.y, pos.x).unwrap();
        // Assign obstacle label to the neighbor
        match (pos.x, pos.y) {
            (0, _) => {
                // Add obstacle label to the top region
                *obstacle_label = 0;
            }
            (_, 0) => {
                // Add obstacle label to the left region
                *obstacle_label = 1;
            }
            _ if pos.x == img.cols() - 1 => {
                // Add obstacle label to the right region
                *obstacle_label = 2;
            }
            _ if pos.y == img.rows() - 1 => {
                // Add obstacle label to the bottom region
                *obstacle_label = 3;
            }
            _ => {
                // Add obstacle label to obstacles
                add_label(
                    img,
                    &mut obstacle_label_map,
                    pos,
                    &mut obstacle_label_idx,
                    &mut obstacle_queue,
                );
            }
        }
    }
    // Now all obstacles have a label
    // Map the Voronoi edges and regions

    // Lable the surrounding pixels for obstacles
    while let Some(pos) = obstacle_queue_copy.pop_front() {
        // Get the distance of the obstacle to closest obstacle
        let obstacle_distance = dtm_img.at_2d::<Vec3b>(pos.y, pos.x).unwrap()[0] as i32;
        let mut neighbor_obstacle_labels = UNINITIALIZED_LABEL;

        let mut smaller_neighbors = Vec::<u8>::new();
        for dir in &DIRECTIONS {
            let neighbor_pos = Point2i::new(pos.x + dir.0, pos.y + dir.1);
            if is_valid_position(img, neighbor_pos) {
                let obstacle_label = *obstacle_label_map
                    .at_2d::<u8>(neighbor_pos.y, neighbor_pos.x)
                    .unwrap();
                let neighbor_label = obstacle_label_map
                    .at_2d_mut::<u8>(neighbor_pos.y, neighbor_pos.x)
                    .unwrap();
                let neighbor_distance = dtm_img
                    .at_2d::<Vec3b>(neighbor_pos.y, neighbor_pos.x)
                    .unwrap()[0] as i32;
                if neighbor_distance < obstacle_distance {
                    smaller_neighbors.push(*neighbor_label);
                } else if neighbor_distance == obstacle_distance {
                    neighbor_obstacle_labels = *neighbor_label;
                }

                // Add uninitialized neighbors to the queue
                if *neighbor_label == UNINITIALIZED_LABEL && neighbor_distance > obstacle_distance {
                    obstacle_queue_copy.push_back(neighbor_pos);
                }
            }
        }

        // Mut reference to update the label
        let obstacle_label = obstacle_label_map.at_2d_mut::<u8>(pos.y, pos.x).unwrap();

        match smaller_neighbors.len() {
            0 => {
                // Assign the Voronoi edge label
                *obstacle_label = neighbor_obstacle_labels;
            }
            1 => {
                // Assign the region label
                *obstacle_label = smaller_neighbors[0];
            }
            _ => {
                // Assign the Voronoi edge label
                *obstacle_label = EDGE_LABEL;
            }
        }
        println!("{:?}", obstacle_queue_copy.len());
    }

    // Generate the GVD image
    let mut gvd_img = img.clone();
    // Draw the the regions
    let colors = util::generate_random_color(obstacle_label_idx as usize);
    for x in 0..img.cols() {
        for y in 0..img.rows() {
            let obstacle_label = obstacle_label_map.at_2d::<u8>(y, x).unwrap();
            let distance = dtm_img.at_2d::<Vec3b>(y, x).unwrap()[0] as i32;
            let gvd_pixel = gvd_img.at_2d_mut::<Vec3b>(y, x).unwrap();

            if *obstacle_label != UNINITIALIZED_LABEL // Avoid out-of-bounds
            && *obstacle_label != EDGE_LABEL // Keep the Voronoi edges white
            && (distance != 0 || x == 0 || y == 0 || x == img.cols() - 1 || y == img.rows() - 1)
            // Keep the obstacles but not the walls
            {
                *gvd_pixel = colors[*obstacle_label as usize];
            }
        }
    }

    // Show the GVD image
    highgui::named_window(WINDOW_NAME, 0).expect("failed to create Brushfire window");
    highgui::move_window(WINDOW_NAME, 0, 520).expect("failed to move window");
    highgui::imshow(WINDOW_NAME, &gvd_img).expect("failed to show Brushfire image");
    highgui::wait_key(1).expect("failed to wait key");
}
